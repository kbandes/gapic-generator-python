{% macro test_api_method_pb2(method, http_options) %}
{# Generate a test for a method with pb2-style (not proto+) input and output messages. #}

def test_{{ method.name }}_rest(
    transport: str = "rest", request_type={{ request }}
):
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
        transport=transport,
    )

    # send a request that will satisfy transcoding
    request_init = {{ http_options[0].sample_request(method) }}
    {% for field in method.body_fields.values() %}
    {% if not field.oneof or field.proto3_optional %}
    {# ignore oneof fields that might conflict with sample_request #}
    request_init["{{ field.name }}"] = {{ field.mock_value_original_type }}
    {% endif %}
    {% endfor %}
    request = request_type(request_init)

    # Mock the http request call within the method and fake a response.
    with mock.patch.object(Session, "request") as req:
        # Designate an appropriate value for the returned response.
        return_value = {{ method.output.ident }}(
            {% for field in method.output.fields.values() | rejectattr('message')%}
            {% if not field.oneof or field.proto3_optional %}
              {{ field.name }}={{ field.mock_value }},
              {% endif %}{% endfor %}
              {# This is a hack to only pick one field  #}
              {% for oneof_fields in method.output.oneof_fields().values() %}
              {% with field = oneof_fields[0] %}
              {{ field.name }}={{ field.mock_value }},
              {% endwith %}
              {% endfor %}
        )

        return_value = {{ response }}(
            next_page_token="next_page_token_value",
        )

        # Wrap the value into a proper Response obj
        response_value = Response()
        response_value.status_code = 200
        json_return_value = json_format.MessageToJson(return_value)
        response_value._content = json_return_value.encode("UTF-8")
        req.return_value = response_value
        response = client.{{ method_name }}(request)

        assert isinstance(response, {{ method.client_output.ident }})
        {% for field in method.output.fields.values() | rejectattr('message') %}
        {% if not field.oneof or field.proto3_optional %}
        {% if field.field_pb.type in [1, 2] %}{# Use approx eq for floats #}
        assert math.isclose(response.{{ field.name }}, {{ field.mock_value }}, rel_tol=1e-6)
        {% elif field.field_pb.type == 8 %}{# Use 'is' for bools #}
        assert response.{{ field.name }} is {{ field.mock_value }}
        {% else %}
        assert response.{{ field.name }} == {{ field.mock_value }}
        {% endif %}
        {% endif %}{# end oneof/optional #}
        {% endfor %}


def test_{{ name }}_rest_failure():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
        transport=transport,
    )

    # send a request that will satisfy transcoding
    request_init = {{ http_options[0].sample_request(method) }}
    {% for field in method.body_fields.values() %}
    {% if not field.oneof or field.proto3_optional %}
    {# ignore oneof fields that might conflict with sample_request #}
    request_init["{{ field.name }}"] = {{ field.mock_value_original_type }}
    {% endif %}
    {% endfor %}
    request = request_type(request_init)

    with mock.patch.object(Session, "request") as req:
        response_value = Response()
        response_value.status_code = 400
        mock_request = mock.MagicMock()
        mock_request.method = "GET"
        mock_request.url = "https://example.com/v1/method"
        response_value.request = mock_request
        req.return_value = response_value
        with pytest.raises(core_exceptions.GoogleAPIError):
            client.{{ name }}(request)


{% endmacro %}
